# 도커 파일

Created: 2022년 9월 25일 오후 3:33
Tags: Docker
분류: Server
작성자: 창모 연

### 이미지 생성 방법

1. 아무것도 존재하지 않는 이미지(우분투, centos)로 컨테이너를 생성
2. 앱을 위한 환경을 설치, 소스코드 복사 후 동작 확인
3. 컨테이너를 이미지로 커밋

장점 : 이미지의 동작을 보장할 수 있음

단점 : 복잡, 귀찮

해결 : 위의 과정을 하나의 파일에 기록하면 도커는 이 파일을 읽어 컨테이너에서 작업을 수행한 뒤 이미지로 생성

빌드 명령어는 Dockerfile을 읽어 이미지를 생성

Dokcerfile을 사용하면 직접 컨테이너를 생성하고, 이미지로 커밋하는 번거로움이 사라지고

깃과 같은 개발 도구를 통해 애플리케이션의 빌드 및 배포를 자동화할 수 있음

### Dockerfile 작성

컨테이너에서 수행해야할 작업을 명시

🍀 도커 엔진은 Dockerfile을 읽을 때 기본적으로 현재 디렉토리에 있는 Dockerfile이라는 이름을 가진 파일을 선택

```jsx
Dockerfile 예시
FROM ubuntu:14.04
MAINTAINER alicek106
LABEL "purpose"="practice"
RUN apt-get update
RUN apt-get install apache2 -y
ADD test.html /var/www/html
WORKDIR /var/www/html
RUN ["/bin/bash", "-c", "echo hello >> test2.html"]
EXPOSE 80
CMD apachectl -DFOREGROUND

도커 파일 명령어 설명
1. FROM : 생성할 이미지의 베이스가 될 이미지를 의미, 도커 파일 작성 시 반드시 한 번 이상 입력
					사용하려는 이미지가 도커에 없다면 자동으로 pull 받음

2. MAINTAINER : 이미지를 생성한 개발자의 정보를 나타냄. 보통 Dockerfile 작성한 사람의 이메일 입력
								도커 1.13.0 버전 이후로 사용하지 않음 ( LABEL 로 교체해 표현 )

3. LABEL : 이미지에 메타데이터를 추가, 키:값 형태로 저장, 여러 개 저장 가능
						추가된 메타데이터는 docker inspect 명령어로 이미지의 정보를 구해서 확인 가능

4. RUN : 이미지를 만들기 위해 컨테이너 내부에서 명령어를 실행
					예시에서는 apt-get update, apt-get install apache2 명령어 실행, 아파치 웹 서버가 설치된 이미지가 생성됨
					Dockerfile 을 이미지로 빌드하는 과정에서 별도의 입력이 불가
					이미지를 빌드할 때 별도의 입력을 받아야 하는 RUN이 있다면 build 명령어는 이것을 오류로 간주, 빌드 종료
					RUN ["/bin/bash", "-c", "echo hello >> test2.html"]
					bin/bash 셸을 이용해 명령어 실행 ( 배열 형태로 사용 가능)
					JSON 배열의 입력 형식을 따르기 때문에 JSON 형식과 일치해야 함
					JSON 배열 형태로 Dockerfile의 명령어를 사용하면 셸을 실행하지 않음
					["echo", "$MY_ENV"] 보단 ["sh", "-c", "echo $MY_ENV"] 

5. ADD : 파일을 이미지에 추가, 추가하는 파일은 Dockerfile이 위치한 디렉터리
					예제에서는 Dockerfile이 위치한 디렉터리에서 test.html 파일을 이미지의 /var/www/html 디렉터리에 추가
					JSON 배열의 형태로 ["추가할 파일 이름", ... "컨테이너에 추가될 위치"] 사용 가능
					추가할 파일명은 여러 개 지정 가능, 배열의 마지막 원소가 컨테이너에 추가될 위치

6. WORKDIR : 명령어를 실행할 디렉터리, bash shell에서 cd 명령어와 동일
							WORKDIR /var/www/html 실행 후 RUN touch test 실행 시 /var/www/html/ 디렉터리의 test 파일이 생성

7. EXPOSE : Dockerfile의 빌드로 생성된 이미지에서 노출할 포트를 설정
						반드시 이 포트가 호스트의 포트와 바인딩되는 것은 아님, 그냥 컨테이너의 80번 포트를 사용할 것을 작성

8. CMD : 컨테이너가 시작될 때마다 실행할 명령어를 설정, 1번만 사용 가능
					
```

### Dockerfile 빌드

1. 이미지 생성
    
    ex) docker build -t mybuild:0.0 ./
    
    -t : 생성될 이미지 저장 옵션 ( 안쓰면 16진수로 이미지 이름 자동 생성 )
    
    mybuild:0.0 : 생성될 이미지 이름
    
    ./ : Dockerfile이 저장된 경로 입력 ( ./ 는 현재 디렉터리를 의미)
    
2. 생성된 이미지로 컨테이너를 실행
    
    ex) docker run -d -P —name myserver mybuild:0.0
    
    -P : 이미지에 설정된 EXPOSE의 모든 포트를 호스트에 연결하도록 설정
    

Dockerfile에 이미지의 라벨을 purpose=”practice”로 설정했으므로 docker images 명령어의 필터에 이 라벨 적용 가능

—filter 옵션을 통해 해당 라벨을 가지는 이미지만 출력

ex) docker images —filter “label=purpose=practice”

1. 빌드 과정 살펴보기
    1. 빌드 컨테스트를 읽음 ( 이미지를 생성하는 데 필요한 각종 파일, 소스코드, 메타데이터를 담고 있는 디렉터리 )
        
        Dockerfile이 위치한 디렉터리가 빌드 컨텍스트
        
        빌드 컨텍스트는 Dockerfile에서 빌드될 이미지에 파일을 추가할 때 사용
        
        추가 방법 ADD, COPY 명령어 사용
        
        1. docker build -t mybuild:0.0 ./ ⇒ test.html 파일을 빌드 컨텍스트에 추가
        2. ADD test.html /var/www/html ⇒ 빌드 컨텍스트에서 test.html 파일을 이미지에 추가
        
        컨텍스트는 build 명령어 맨 마지막에 지정된 위치에 있는 파일을 전부 포함
        
        외부 URL에서 Dockerfile을 읽어 들인다면 해당 저장소에 있는 파일, 서브 모듈을 포함
        
        따라서 Dockerfile이 위치한 곳에는 이미지 빌드에 필요한 파일만 있는 것이 바람직
        
        💣 루트 디렉터리(/)와 같은 곳에서 이미지를 빌드하지 않도록 주의
        
        🍀 .dockerignore 파일 작성 방법도 있음( Dockerfile 이 위치한 곳에 같이 위치해야 함)
        
    2. Dockerfile을 이용한 컨테이너 생성과 커밋
        
        ADD, RUN 등의 명령어가 실행될 때마다 새로운 컨테이너가 하나씩 생성 이를 이미지로 커밋
        
        Dockerfile 명령어 한 줄이 실행될 때마다 이전 Step에서 생성된 이미지에 의해 새로운 컨테이너가 생성
        
        Dockerfile 에 적힌 명령어를 수행하고 다시 새로운 이미지 레이어로 저장됨
        
        이미지의 빌드가 완료되면 명령어 줄 수만큼의 레이어가 존재, 중간에 컨테이너도 같은 수만큼 생성, 삭제
        
    3. 캐시를 이용한 이미지 빌드
        
        한 번 이미지 빌드를 마치고 난 뒤 다시 같은 빌드를 진행하면 이전의 이미지 빌드에서 사용한 캐시 사용
        
        💣 이미지 빌드 실패
        
        1. 이미지 빌드 중 오류가 발생하면 build 명령어 중지
        2. 이미지 레이어 생성을 위해 마지막으로 생성된 임시 컨테이너가 삭제되지 않은 채로 남게 됨
        3. -t 옵션으로 지정한 이미지 이름이 아닌 <noe> : <none>으로 이미지 생성
        4. docker rmi [이미지 ID]    명령어로 삭제
    
    🍀 캐시 사용이 불필요한 경우 ( 원격 저장소(깃헙,깃랩)에서 git clone 명령어 사용할 때 )
    
    Dockerfile에 RUN git clone … 명령어를 사용해 이미지를 빌드했다면 
    
    RUN에 대한 이미지 레이어를 계속 캐시로 사용하기 때문에 실제 깃 저장소에서 변경이 일어나도 이전 것 사용
    
    docker build —no-cache -t mybuild:0.0  ⇒ 기존 빌드에 사용된 캐시를 사용하지 않고 Dockerfile 처음부터 빌드
    
    docker build —cache-from nginx -t my_extend_nginx:0.0 ⇒ 캐시로 사용할 이미지를 직접 지정
    
2. 멀티 스테이지를 이용한 Dockerfile 빌드하기
    
    일반적으로 애플리케이션을 빌드할 땐 많은 의존성 패키지와 라이브러리가 필요함
    
    멀티 스테이지 빌드  
    
    하나의 Dockerfile 안에 여러 개의 FROM 이미지를 정의함으로써 빌드 완료 시 생성될 이미지의 크기를 줄이는 것
    
    ```jsx
    FROM golang
    # FROM golang as builder
    ADD main.go /root
    WORKDIR /root
    RUN go build -o /root/mainApp /root/main.go
    
    FROM alpine:latest
    WORKDIR /root
    COPY --from:0 /root/mainApp .
    # COPY --from:builder /root/mainApp .
    CMD ["./mainApp"]
    
    설명
    ADD main.go /root : main.go 파일을 이미지의 /root 위치에 추가
    RUN go build -o /root/mainApp /root/main.go : go build -o [만들어질 실행 파일 이름] [빌드할 파일]
    
    COPY --from:0 /root/mainApp . : 0번 FROM 에서 /root/mainApp 위치의 파일을 현재 위치(.)에 복사
    ```
    

### 기타 Dockerfile 명령어

```jsx
1. ENV : Dockerfile 에서 사용될 환경변수를 지정
				설정한 환경변수는 ${ENV_NAME} 또는 $ENV_NAME의 형태로 사용할 수 있음
				Dockerfile 뿐 아니라 빌드된 이미지로 컨테이너를 생성하면 환경변수 사용 가능
				run 명령어에서 -e 옵션을 사용해 같은 이름의 환경변수를 사용하면 덮어써짐
FROM ubuntu:14.04
ENV test /home
WORKDIR $test
RUN touch $test/mytouchfile

docker run -it env_test_override \
-e test=myvalue

Dockerfile에서 환경변수의 값을 사용할 때 값이 설정된 경우, 설정되지 않은 경우 구분해 사용 가능
${env_name:-value} : 값 O : 지정한 값을 사용, 값 X : value 를 값으로 사용
${env_name:+value} : 값 O : value 를 값으로 사용, 값 X : 빈 문자열 사용
FROM ubuntu:14.04
ENV test /home
RUN echo ${test:-value} / ${test:+value} / ${test2:-value} / ${test2:+value}

/home / value / value / 

2. VOLUME : 빌드된 이미지로 컨테이너를 생성했을 때 호스트와 공유할 컨테이너 내부의 디렉터리 설정
						VOLUME ["/home/dir", "home/dir2"] 처럼 JSON 배열의 형식으로 여러 개 사용 또는
						VOLUME /home/dir /home/dir2 형식으로 사용

FROM ubuntu:14.04
RUN mkdir /home/volume
RUN echo test >> /home/volume/testfile
VOLUME /home/volume

이미지를 빌드한 뒤 컨테이너 생성 후 볼륨의 목록을 확인하면 볼륨 생성을 확인할 수 있다.
생성된 볼륨은 컨테이너 내부의 /home/volume 디렉터리를 호스트와 공유함

3. ARG : build 명령어를 실행할 때 추가로 입력을 받아 Dockerfile 내에서 사용될 변수의 값을 설정

FROM ubuntu:14.04
ARG my_arg
ARG my_arg_2=value2
RUN touch ${my_arg}/mytouch

my_arg, my_arg_2 변수를 추가로 입력 받을 것, 기본 값 지정 가능

build 명령어 실행 시 --build-arg 옵션을 사용해 ARG에 값 입력 가능
docker build --build-arg my_arg=/home -t myarg:0.0 ./

ARG와 ENV의 값을 사용하는 방법은 ${}로 동일, ARG로 설정한 변수를 ENV로 또 쓰면 덮어짐

4. USER : USER로 컨테이너 내에서 사용될 사용자 계정의 이름, UID를 설정하면
					그 아래의 명령어는 해당 사용자 권한으로 실행
					일반적으로 RUN으로 사용자의 그룹과 계정을 생성한 뒤 사용
					루트 권한이 필요하지 않다면 USER를 사용하는 것을 권장

...
RUN groupadd -r author && useradd -r -g author alicek106
USER alicek106
...

컨테이너 내부는 기본적으로 root 계정으로 설정됨
배포할 때 컨테이너 내부에서 새로운 사용자를 새롭게 생성해 사용하는 것을 권장
Dockerfile 내부에 지정을 권장, docker run 명령어 옵션 --user 으로도 지정 가능

5. ONBUILD : 빌드된 이미지를 기반으로 하는 다른 이미지가 Dockerfile로 생성될 때 실행할 명령어를 추가

# Dockerfile
FROM ubuntu:14.04
RUN echo "this is onbuild test"!
ONBUILD RUN echo "onbuild!" >> /onbuild_file

docker build ./ -t onbuild_test:0.0

# Dockerfile2
FROM onbuild_test:0.0
RUN echo "this is child image!"

docker build -f ./Dockerfile2 ./ -t onbuild_test:0.1
해당 명령어를 수행할 때 Dockerfile 의 ONBUILD 동작한다.
.f 명령어를 사용해 빌드할 파일( Dockerfile2 ) 지정, 같은 폴더 내에 Dockerfile 이 2개여서

ONBUILD 의 좋은 활용 방법
이미지가 빌드하거나 활용할 소스코드를 ONBUILD ADD로 추가해 깔끔하게 Dockerfile을 사용하는 것

이 이미지를 사용하는 개발자는 프로젝트 폴더에 Dockerfile을 위치시키고
아래의 Dockerfile로부터 빌드된 이미지를 FROM 항목에 입력함으로써 메이븐을 사용할 수 있음

FROM maven:3-jdk-8-alpine
RUN mkdir -p /usr/src/app
WORKDIR /usr/src/app
ONBUILD ADD . /usr/src/app
ONBUILD RUN mvn install

6. STOPSIGNAL : 컨테이너가 정지될 때 사용될 시스템 콜의 종류를 지정

FROM ubuntu:14.04
STOPSIGNAL SIGKILL

docker run --stop-signal 옵션으로도 설정 가능

7. HEALTHCHECK : 이미지로부터 생성된 컨테이너에서 동작하는 애플리케이션의 상태를 체크하도록 설정
								컨테이너 내부에서 동작죽인 애플리케이션의 프로세스가 종료되지는 않았으나
								동작하지 않은 상태를 방지하기 위해 사용

FROM nginx
RUN apt-get update -y && apt-get install curl -y
HEALTHCHECK --interval=1m --timeout=3s --retries-3 CMD curl -f http://localhost || exit 1

--interval : 컨테이너 상태를 체크하는 주기
CMD ~ : 상태를 체크하는 명령어
--timeout : 설정한 시간을 초과하면 상태 체크에 실패한 것으로 간주
--retries : 횟수만큼 명령어를 반복, 상태 체크 실패 시 해당 컨테이너는 unhealthy 상태로 간주

8. COPY : 로컬 디렉터리에서 읽어 들인 컨텍스트로부터 이미지에 파일을 복사하는 역할
ADD 와 COPY의 사용 방법은 같다.

COPY test.html /home/
COPY ["test.html", "/home/"]

ADD 와 COPY의 차이점은 추가하는 파일의 위치다.
COPY는 로컬의 파일만 이미지에 추가할 수 있는 반면
ADD는 외부 URL 및 tar 파일에서도 파일을 추가할 수 있음

ADD https://raw.githubusercontent.com/alicek106/mydockerrepo/master/test.html /home
tar 파일도 추가 가능, tar 파일 그대로 추가하는 것이 아닌 자동으로 해제해서 추가
ADD test.tar /home

ADD 사용은 권장하지 않음
URL이나 tar 파일을 추가할 경우 이미지에 정확히 어떤 파일이 추가될지 알 수 없기 때문
COPY는 로컬 컨텍스트로부터 파일을 직접 추가하기 때문에 빌드 시점에서도 어떤 파일이 추가될지 명확

9. ENTRYPOINT
CMD, ENTRYPOINT는 컨테이너가 시작할 때 실행할 명령어를 설정
ENTRYPOINT 는 CMD를 인자로 받아 사용할 수 있는 스크립트의 역할을 할 수 있다.

docker run -it --name no_entrypoint ubuntu:14.04 /bin/bash
=> bash shell이 실행됨

docker run -it --name --entrypoint="echo" ubuntu:14.04 /bin/bash
=> /bin/bash 가 출력됨

entrypoint 가 설정되지 않았다면 cmd에 설정된 명령어를 그대로 실행,
entrypoint 가 설정되어 있다면 cmd에 설정된 명령어는 entrypoint에 대한 인자의 기능

entrypoint 를 이용한 스크립트 실행
entrypoint의 인자로 스크립트 파일을 사용해 컨테이너가 시작될 때마다 해당 스크립트 파일을 실행하도록 설정
스크립트 파일의 이름을 entrypoint의 인자로 입력

docker run -it --name entrypoint_sh --entrypoint="/test.sh" ubuntu:14.04 /bin/bash
단 실행할 스크립트 파일은 컨테이너 내부에 존재해야 함 ( 이미지 내에 스크립트 파일이 존재 )

Dockerfile 중 이미지에 파일을 추가하는 방법 ( COPY, ADD )
1. 어떤 설정 및 실행이 필요한지에 대해 스크립트로 정리
2. ADD, COPY 로 스크립트를 이미지로 복사
3. ENTRYPOINT를 이 스크립트로 설정
4. 이미지를 빌드해 사용
5. 스크립트에서 필요한 인자는 docker run 명령어에서 cmd로 entrypoint의 스크립트에 전달

# Dockerfile
FROM ubuntu:14.04
RUN apt-get update
RUN apt-get install apache2 -y
ADD entrypoint.sh /entrypoint.sh
RUN chmod +x /entrypoint.sh
ENTRYPOINT ["/bin/bash", "**/**entrypoint**.sh"]

#** entrypoint.sh
echo $1 $2
apachectl -DFOREGROUND

docker build -t entrypoint_image:0.0
docker run -d --name entrypoint_apache_server entrypoint_image:0.0 first second
docker logs entrypoint_apache_server
=> first second
```

### JSON 배열 형태와 일반 형식의 차이점

```jsx
CMD, ENTRYPOINT에 설정하려는 명령어를 /bin/sh로 사용할 수 없다면
JSON 배열의 형태로 명령어를 설정
JSON 배열 형태가 아닌 CMD, ENTRYPOINT를 사용하면 실제로 이미지를 생성할 때 cmd, entrypoint에 /bin/sh -c 가 앞에 추가되기 때문

CMD, ENTRYPOINT 명령어가 동시에 사용된 Dockerfile 일 때
CMD echo test
→ /bin/sh -c echo test

ENTRYPOINT /entrypoint.sh
→ /bin/sh -c /entrypoint.sh
실제 컨테이너에서 실행되는 명령어는 /bin/sh -c [entrypoint.sh](http://entrypoint.sh) /bin/sh -c echo test

CMD [”echo”, “test”]
→ echo test

ENTRYPOINT [”/bin/sh”, “/entrypoint.sh”]
→ /bin/sh /entrypoint.sh
실제 컨테이너에서 실행되는 명령어는 /bin/sh [entrypoint.sh](http://entrypoint.sh) echo test
```

### Dockerfile 로 빌드할 때 주의할 점

```jsx
좋은 방법 : \ (역슬래시) 이용하기

vi Dockerfile
Run apt-get install package1 \
package2 \
package3

잘못된 Dockerfile 사용

FROM ubuntu
RUN mkdir /test
RUN fallocate -1 100m /test/dummy
RUN rm /test/dummy

해당 도커파일은 기본 이미지에 100MB 파일(/test/dummy) 를 추가 할당 한 뒤 삭제하는 코드이다.
하지만 실제 생성되는 이미지의 크기는 기본 이미지 크기 + 100MB 그대로이고 해당 파일은 삭제된다.

왜 그럴까?
4번째 줄 명령어로 해당 파일을 삭제한 상태로 이미지를 빌드했기 때문이다.
컨테이너를 이미지로 생성할 때 컨테이너에서 변경된 사항만 새로운 이미지 레이어로 생성하는 방식의 단점이다.
RUN rm /test/dummy 명령어를 수행해 100MB 크기의 파일을 삭제하더라도
이는 “파일을 삭제했다” 라는 변경사항으로서의 레이어로 새롭게 저장될 뿐,
실제 100MB 크기 파일은 이전 레이어에 남아있기 때문
실제로 컨테이너에서 사용하지 못하는 파일이 이미지 레이어로 존재하기 때문에 저장 공간은 차지하지만 실제로는 의미가 없는 저장 공간일 수도 있는 것

해결 방법 : 하나의 이미지 레이어에 다 넣는다.

FROM ubuntu
RUN mkdir /test && \
fallocate -1 100m /test/dummy && \
rm /test/dummy
```

도커 이미지 레이어 생성 예시

| rm /test/dummy | 파일 삭제 레이어 |
| --- | --- |
| fallocate -1 100m /test/dummy | 파일 생성 레이어 |
| mkdir /test | 폴더 생성 레이어 |
| ubuntu | 기본 이미지 |

```jsx
FROM ubuntu
RUN mkdir /test && \
fallocate -1 100m /test/dummy && \
rm /test/dummy

docker run -dit --name temp falloc_100mb:0.0
=> 기본 이미지 + 1개의 레이어

docker export temp | docker import - falloc_100mb:0.1
=> 기본 이미지 1개 설정된 이미지 파일 생성( 복사 )

docker run -dit --name temp2 falloc_100mb:0.1
=> 실행 에러, Error response form daemon: No command specified
ubuntu 이미지의 커맨드 명령어가 손실되어 설정되지 않았고
entrypoint 또한 설정되지 않아 에러를 출력하며 컨테이너가 생성되지 않음

무슨 말인지 몰라 검색
컨테이너의 파일 시스템을 아카이빙(저장??) 하고 다시 이미지로 만든 것이므로
Docker는 이 이미지의 entrypoint가 무엇인지 알지 못한다.
이렇게 만든 이미지를 실행할 때 엔트리 포인트를 직접 지정해주어야 한다.

docker run -dit --name temp2 falloc_100mb:0.1 /bin/bash
=> 정상 작동
```