# 서버

### **주의 !! SSAFY 특화프로젝트 기준으로 작성되었습니다(2022/09/21)**

## 사용 기술 스택

- AWS EC2
- Docker
- Jenkins
- Nginx
- Let’s Encrypt(certbot)
- SpringBoot
- Vue

### 참고 링크

[[서버 환경 설정 전 과](https://www.notion.so/a1d39fc1932b4a8a94c588fc20f30c72)[정](https://github.com/hjs101/CICD_manual)(Django, React)](https://www.notion.so/Django-React-599c07df7fdd4291a7fe41b1f3b3e54e)

## 1. 환경 설정

### 1.1 EC2 서버에 Docker 설치

🍀 Ubuntu 환경에 Docker 설치

1.1.1 사전 패키지 설치

도커 설치를 위해 필요한 패키지 설치

```jsx
설치 가능한 패키지 리스트 최신화 (O), 시스템 업데이트 (X)
sudo apt update

sudo apt-get install -y ca-certificates \
    curl \
    software-properties-common \
    apt-transport-https \
    gnupg \
    lsb-release
```

패키지 설명

- ca-certificates : SSL 기반 앱이 SSL 연결 되어 있는지 확인
- curl : 서버와 통신하기 위해 사용
- apt-transport-https : 패키지 관리자가 https를 통해 데이터 및 패키지 접근
- software-properties-common : PPA 를 추가하거나 제거
    - PPA( Personal Package Archive) : 개인 패키지 저장소
- gnupg : 통신 상 or 데이터 저장할 때 보안을 지키는 도구, 데이터를 암호화하고 전자 서명을 만들 수 있으며 암호화 도구로 유명한 PGP를 완벽하게 대신할 수 있다.
    - [gnupg 설명 참고사이트](http://www.linuxlab.co.kr/docs/01-01-3.htm)
- lsb-release : 리눅스 배포판 코드명 확인 명령어
    - [추가 설명](https://idchowto.com/%EB%A6%AC%EB%88%85%EC%8A%A4-%EB%B0%B0%ED%8F%AC%ED%8C%90-%EB%B2%84%EC%A0%84-%ED%99%95%EC%9D%B8-lsb_release/)
    

1.1.2 도커 설치를 위해 gpg Key 다운

```jsx
sudo mkdir -p /etc/apt/keyrings
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg

echo \
    "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
    $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
```

패키지 설명

- mkdir -p /etc/apt/keyrings
    - mkdir : 디렉토리(폴더) 생성
    - -p : 옵션, 필요한 경우 상위 경로까지 생성
    - /etc/apt/keyrings : 생성 경로
- curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
    - 도커를 설치하기 위해 gpg Key를 다운받아야 합니다. 이는 리눅스 패키지 툴이 프로그램 패키지가 유효한지 확인하기 위해 설치 전에 gpg 키를 통해 검증하는 과정을 거치기 때문에 gpg 키를 받아야 한다고 합니다.
- echo
    - 화면 출력을 담당하는 명령어
    - ex) echo hello
    - 출력 ⇒ hello
- tee
    - 표준 입력에서 읽어 표준 출력과 파일에 쓰는 명령어
    - ex) `echo "hello" | tee OUTFILE`
    

1.1.3 도커 설치

`apt update`를 다시 실행해주고, 아래 명령어를 통해 도커를 설치합니다. 

`docker-compose`는 추가로 설치합니다.(젠킨스 설치할 때 편하게 하기 위해 씁니다. 다른 사용법도 있는데 저는 이번에는 쓰지 않았습니다.)

```jsx
sudo apt update
sudo apt install docker-ce docker-ce-cli containerd.io docker-compose
```

## 1.2 젠킨스 설치

### 1.2.1 docerk-compose 이용 젠킨스 컨테이너 생성

다음 명령어를 이용하여 docker-compose.yml 파일을 생성합니다.

![Untitled](%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5%208517c03771dc466cbe472774aea3bc4b/Untitled.png)

docker-compose.yml 파일

```jsx
version: '3'

services:
    jenkins:
        image: jenkins/jenkins:lts
        container_name: jenkins
        volumes:
            - /var/run/docker.sock:/var/run/docker.sock
            - /jenkins:/var/jenkins_home
        ports:
            - "9090:8080"
        privileged: true
        user: root
```

위 내용을 복사하여 붙여넣기합니다. 각 단어에 대한 설명은 간단하게만 하겠습니다.

- services : 컨테이너 서비스
- jenkins : 서비스 이름
- image : 컨테이너 생성시 사용할 image, 여기서는 jenkins/jenkins:lts 이미지를 사용(jenkins의 lts버전을 가져온다는 뜻)
- container_name : 컨테이너 이름
- volumes : 공유 폴더 느낌, aws의 /var/run/docker.sock와 컨테이너 내부의 /var/run/docker.sock를 연결, /jenkins 폴더와 /var/jenkins_home 폴더를 연결.
- ports : 포트 매핑, aws의 9090 포트와 컨테이너의 8080 포트를 연결한다.
- privileged : 컨테이너 시스템의 주요 자원에 연결할 수 있게 하는 것 기본적으로 False로 한다고 한다.
- user : 젠킨스에 접속할 유저 계정 (root로 할 경우 관리자)

![Untitled](%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5%208517c03771dc466cbe472774aea3bc4b/Untitled%201.png)

이후 esc를 누른 후 :wq 를 입력하여 파일을 저장합니다.

![Untitled](%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5%208517c03771dc466cbe472774aea3bc4b/Untitled%202.png)

`sudo docker-compose up -d` 명령어를 입력하여 컨테이너를 생성해줍니다. 

컨테이너가 생성되고 돌아가는 것을 보려면 -d 를 빼고 입력해줍니다.

![Untitled](%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5%208517c03771dc466cbe472774aea3bc4b/Untitled%203.png)

`sudo docker ps` 명령어로 다음과 같이 컨테이너가 올라가 있는 것을 확인할 수 있습니다.

### 1.2.2 젠킨스 계정 생성 및 플러그인 설치

![Untitled](%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5%208517c03771dc466cbe472774aea3bc4b/Untitled%204.png)

서버 공인 IP:9090 포트로 접속하면 다음과 같은 젠킨스 시작 화면이 나타나게 됩니다.

![Untitled](%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5%208517c03771dc466cbe472774aea3bc4b/Untitled%205.png)

여기서 말하는 Administrator password는 `sudo docker logs jenkins` 명령어를 통해 위 사진의 빨간 네모 상자 안의 값을 입력해줍니다.

다음으로 두 개의 버튼 중 `Install suggested plugins`를 클릭해줍니다.(기본 플러그인 자동 설치 느낌, 다른 버튼은 사용자 지정 플러그인 설치 같은 느낌입니다.)

💣 저는 Pipeline 관련 플러그인 3가지가 다운로드 되지 않았는데 큰 문제는 없었습니다.

![Untitled](%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5%208517c03771dc466cbe472774aea3bc4b/Untitled%206.png)

이것 저것 플러그인들이 설치되는 모습입니다.

![Untitled](%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5%208517c03771dc466cbe472774aea3bc4b/Untitled%207.png)

젠킨스 계정 생성 form입니다. 적당히 입력하고 `Save and Continue` 버튼을 눌러줍니다.

이후 `Save and Finish`, `Start using Jenkins` 버튼을 이어서 눌러 젠킨스를 시작해줍니다.

![Untitled](%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5%208517c03771dc466cbe472774aea3bc4b/Untitled%208.png)

젠킨스 시작 메인화면입니다. 플러그인 설치를 위해 jenkins 관리 탭을 클릭해줍니다.

![Untitled](%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5%208517c03771dc466cbe472774aea3bc4b/Untitled%209.png)

플러그인 관리 페이지로 이동합니다.

![Untitled](%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5%208517c03771dc466cbe472774aea3bc4b/Untitled%2010.png)

먼저 설치 가능 탭으로 탭을 변경해주고, 검색어에 `gitlab`을 검색합니다.

그 후, 밑줄 친 플러그인들을 체크하고, `install witout restart` 버튼을 클릭해줍니다.

![Untitled](%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5%208517c03771dc466cbe472774aea3bc4b/Untitled%2011.png)

같은 방식으로 Docker 관련 플러그인도 설치해줍니다.

![Untitled](%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5%208517c03771dc466cbe472774aea3bc4b/Untitled%2012.png)

마지막으로 SSH 연결 관련 플러그인까지 설치하겠습니다.

![Untitled](%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5%208517c03771dc466cbe472774aea3bc4b/Untitled%2013.png)

모두 설치가 완료되었습니다.

### 1.2.3 젠킨스 프로젝트 생성 Webhook 설정, 자동 빌드 테스트

이제, 젠킨스에서 프로젝트를 생성하고, 깃랩과 WebHook으로 연결하여 자동으로 빌드를 진행하는 것을 테스트하겠습니다.

🍀 **깃랩 Repo 생성**

깃랩 레포지토리 생성 부분은 모두 잘 알고 있을 거라고 생각하여 스킵하고, 제가 구성한 레포지토리가 어떻게 되어있는지 간단하게 설명만 하겠습니다.

![Untitled](%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5%208517c03771dc466cbe472774aea3bc4b/Untitled%2014.png)

여기서는 SpringBoot 와 Vue를 이용하여 배포를 진행할 것이기 때문에 폴더로 구분지어 각각 SpringBoot, Vue 프로젝트를 설치해두었습니다.

`testproject`는 SpringBoot 프로젝트, `testproject_react`는 Vue  프로젝트입니다.

💣 캡쳐된 이미지 내의 폴더 이름과 설명이 다른 이유는 제가 참고한 사이트의 캡쳐이기 때문입니다.

🍀 **젠킨스 프로젝트 생성**

![Untitled](%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5%208517c03771dc466cbe472774aea3bc4b/Untitled%2015.png)

젠킨스 메인페이지에서 `새로운 item` 을 클릭합니다.

![Untitled](%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5%208517c03771dc466cbe472774aea3bc4b/Untitled%2016.png)

프로젝트 이름은 `deploytest`, `Freestyle project`를 클릭하고 `OK` 버튼을 클릭합니다.

![Untitled](%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5%208517c03771dc466cbe472774aea3bc4b/Untitled%2017.png)

`소스코드 관리` 탭을 클릭하고, None로 되어있는 것을 git 라디오 버튼을 클릭하면 아래에 Form이 나타납니다.

![Untitled](%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5%208517c03771dc466cbe472774aea3bc4b/Untitled%2018.png)

`Repository URL`에는 싸피깃 레포지토리 URL을 입력해줍니다. 위 사진처럼 에러 메시지가 나타나는 것이 지금 단계에서는 정상입니다.

![Untitled](%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5%208517c03771dc466cbe472774aea3bc4b/Untitled%2019.png)

`Credentials`에서, `add` -> `jenkins`를 클릭해줍니다.

![Untitled](%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5%208517c03771dc466cbe472774aea3bc4b/Untitled%2020.png)

- Username : 싸피깃 아이디
- Password : 싸피킷 비밀번호 ( 안된다면 초기 비밀번호)
- ID : Credential 구별할 아무 텍스트 입력하면 됩니다.

위 내용 입력하고 `Add` 버튼 클릭합니다.

![Untitled](%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5%208517c03771dc466cbe472774aea3bc4b/Untitled%2021.png)

`Credentials`에서 이제 만들어진 `Credential`을 선택했을 때 오류메시지가 사라지면 성공입니다.

💣 저는 계정 인증이 위의 방법으로 되지 않아 다음 방법으로 진행하였습니다.

💣 오류 메세지가 사라지지 않는 분만 진행하시면 되겠습니다.

![Untitled](%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5%208517c03771dc466cbe472774aea3bc4b/Untitled%2022.png)

진행 중인 프로젝트의 깃랩으로 들어가 좌측 Settings → Access Tokens 로 들어갑니다.

![Untitled](%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5%208517c03771dc466cbe472774aea3bc4b/Untitled%2023.png)

Token name : 생성될 토큰 이름 지정( 아무거나 입력)

Expiration date :  토큰 만료 날짜 지정 ( EC2 서버 반납날 or 원하는 날)

Select a role : Maintainer 선택

Select scopes : 모두 선택

🍀🍀🍀**이후 [토큰 생성] 버튼을 클릭하면 토큰( Your New Personal Access Token)이 생성됩니다.** 

🍀🍀🍀**생성된 토큰은 생성 당시 1번만 보여주기 때문에 꼭 복사하셔서 저장해두셔야합니다.**

![Untitled](%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5%208517c03771dc466cbe472774aea3bc4b/Untitled%2024.png)

다시 젠킨스로 돌아가 ID, Password(생성된 token)를 입력해서 인증을 시도합니다.

🍀[젠킨스 이동](https://www.notion.so/8517c03771dc466cbe472774aea3bc4b)

💣계정 인증 방법 마무리

![Untitled](%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5%208517c03771dc466cbe472774aea3bc4b/Untitled%2025.png)

다음은 빌드 유발 탭입니다. 빌드 유발 탭에서는 먼저 밑줄 친 부분의 체크박스를 체크해줍니다. 그 후 생기는 고급 버튼을 클릭합니다.

![Untitled](%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5%208517c03771dc466cbe472774aea3bc4b/Untitled%2026.png)

그 후 조금 스크롤을 내려 `Secret token`을 찾아 Generate 버튼을 누르면 사진과 같이 토큰이 생성됩니다. 이 토큰은 Gitlab과 WebHook을 연결할 때 사용되니 저장해둡니다.

![Untitled](%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5%208517c03771dc466cbe472774aea3bc4b/Untitled%2027.png)

다음은 Build 탭입니다. `Add build step`를 클릭하고, `Execute Shell`을 선택해줍니다.

![Untitled](%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5%208517c03771dc466cbe472774aea3bc4b/Untitled%2028.png)

다음과 같이 명령어를 입력할 수 있는 칸이 나타납니다. 

일단 연결만 테스트하는 것이기 때문에 pwd 명령어를 입력하겠습니다.

여기까지 모두 완료했다면 저장 버튼을 눌러 저장합니다.

![Untitled](%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5%208517c03771dc466cbe472774aea3bc4b/Untitled%2029.png)

저장 버튼을 누르면 위 사진처럼 프로젝트 화면으로 이동합니다. 일단 `지금 빌드`
 버튼을 눌러서 젠킨스 수동 빌드를 진행해봅니다. 아래 밑줄처럼 완료 표시가 뜨면 성공한 것입니다.

![Untitled](%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5%208517c03771dc466cbe472774aea3bc4b/Untitled%2030.png)

빌드 히스토리에서, `Console Output`에 들어가보겠습니다.

![Untitled](%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5%208517c03771dc466cbe472774aea3bc4b/Untitled%2031.png)

빌드에 성공한 console 창입니다. 입력해두었던 명령어 pwd도 잘 작동한 것을 확인할 수 있습니다.

🍀 **깃랩 WebHook 연결**

다음은 싸피깃 레포지토리와 젠킨스를 `WebHook`으로 연결하여 자동 빌드를 진행해보겠습니다.

![Untitled](%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5%208517c03771dc466cbe472774aea3bc4b/Untitled%2032.png)

배포할 프로젝트가 있는 깃랩 `Repository`에서 밑줄친 위치로 `WebHooks` 페이지로 이동합니다.

![Untitled](%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5%208517c03771dc466cbe472774aea3bc4b/Untitled%2033.png)

URL에는 `http://배포서버공인IP:9090/project/생성한jenkins프로젝트이름/`을 입력해줍니다.

Secret token에는 아까 위에서 젠킨스 프로젝트를 생성할 때 저장해둔 값을 입력합니다.

빌드 유발 Trigger으로, `Push events, Merge request events`를 설정합니다. 대상 Branch는 master으로 설정합니다.

완료했다면 Add Webhook 버튼을 눌러 webhook을 생성합니다.

![Untitled](%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5%208517c03771dc466cbe472774aea3bc4b/Untitled%2034.png)

WebHook을 생성하고 나면 빌드 테스트를 위해 생성된 WebHook에서 test를 누르고, Push events를 선택해줍니다.

![Untitled](%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5%208517c03771dc466cbe472774aea3bc4b/Untitled%2035.png)

응답이 잘 넘어온 것을 확인할 수 있습니다. (code 200)

![Untitled](%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5%208517c03771dc466cbe472774aea3bc4b/Untitled%2036.png)

젠킨스에서도 정상적으로 빌드가 수행되는 것을 확인할 수 있습니다.

😆 여기까지 완료했으면 이제 `Jenkins`와 `Gitlab`이 연결되었습니다! 연결된 `Gitlab`의 `master branch`에 이벤트가 발생하면, 젠킨스에서는 빌드를 수행하게 됩니다!

### 1.2.4 젠킨스와 연결된 gitlab 프로젝트로 도커 이미지 빌드하기

젠킨스에서 도커 빌드를 하기 위해서는 젠킨스 컨테이너 안에 도커를 설치해야 합니다. 도커 설치 방법은 Ec2에 도커를 설치할 때와 동일하게 진행합니다.

먼저 젠킨스 bash shell에 접근해보겠습니다. 명령어는 `sudo docker exec -it jenkins bash` 입니다.

![Untitled](%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5%208517c03771dc466cbe472774aea3bc4b/Untitled%2037.png)

정상적으로 접속되면 다음과 같은 화면이 됩니다. 이제 이 환경에 docker를 다시 설치하도록 합니다.

💣 **AWS EC2 서버에서의 도커 설치와 같기 때문에 패키지 설명은 생략하겠습니다.**

🍀 사전 패키지 설치

```jsx
apt update
apt-get install -y ca-certificates \
    curl \
    software-properties-common \
    apt-transport-https \
    gnupg \
    lsb-release
```

루트계정으로 접속되어있기 때문에, 젠킨스 컨테이너 내부에서는 명령어에 sudo를 지워야합니다.

🍀 gpg 키 다운로드

```jsx
mkdir -p /etc/apt/keyrings
curl -fsSL https://download.docker.com/linux/debian/gpg | gpg --dearmor -o /etc/apt/keyrings/docker.gpg

echo \
    "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/debian \
    $(lsb_release -cs) stable" | tee /etc/apt/sources.list.d/docker.list > /dev/null
```

젠킨스에 gpg 키를 다운로드 받을 때의 변경사항입니다.

![Untitled](%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5%208517c03771dc466cbe472774aea3bc4b/Untitled%2038.png)

기존 링크에서 제공한 방식은 `ubuntu os`에 대한 `gpg` 키를 다운로드 하는 것이기 때문에, 이를 `debian`으로 바꾸어주어야 합니다.

이를 바꾸지 않으면 패키지를 찾지 못하는 에러가 발생합니다.

기존 명령어에서 `ubuntu`로 되어있는 부분을 `debian`으로 바꾸어주면 해결됩니다.

🍀 **도커 설치**

```jsx
apt update
apt install docker-ce docker-ce-cli containerd.io docker-compose
```

여기까지 진행하면 `Jenkins Container`에도 `Docker`가 설치 완료되었습니다.

🍀 ****프로젝트에 DockerFile 작성****

이제 깃랩의 각 프로젝트 폴더에 DockerFile을 만들어 명령어를 입력해주겠습니다.

SpringBoot Project DockerFile

```jsx
FROM openjdk:11
WORKDIR /var/jenkins_home/workspace/deploytest/testproject
COPY build/libs/percast-0.0.1-SNAPSHOT.jar app.jar
ENTRYPOINT ["java","-jar","app.jar"]
```

`SpringBoot DockerFile`에서는 `openjdk:11` 이미지를 베이스 이미지로 두고, 

작업 경로를 `gitlab의 springboot 폴더`  로 지정해줍니다.

빌드된 jar 파일을 app.jar로 복사한 뒤

`ENTRYPOINT` 명령어를 통해 실행합니다. 

Vue Project DockerFile

```jsx
FROM node:16.15.0 as build-stage
WORKDIR /var/jenkins_home/workspace/deploytest/testproject_vue
COPY package*.json ./
RUN npm install
COPY . .
RUN npm run build
FROM nginx:stable-alpine as production-stage

COPY --from=build-stage /var/jenkins_home/workspace/deploytest/testproject_vue/build /usr/share/nginx/html
#COPY --from=build-stage /var/jenkins_home/workspace/deploytest/testproject_vue/deploy_conf/nginx.conf /etc/nginx/conf.d/default.conf
EXPOSE 80
CMD ["nginx", "-g","daemon off;"]
```

간단 명령어 설명

- FROM : 베이스 이미지를 지정
- WORKDIR : 작업 디렉토리 설정
- COPY : 파일 복사 <Host 파일 경로> <Docker 이미지 파일 경로>
- RUN : 명령 실행
- CMD 컨테이너 실행 명령
- EXPORT : 포트 익스포트

`Vue DockerFile`에서는 먼저 `node:16.15.0` 이미지를 베이스 이미지로 둡니다. as `build-stage`는 이미지를 지칭하는 별명을 말합니다.

그 후 `package*.json`에 등록되어있는 라이브러리들을 `npm install`으로 설치하고, 프로젝트 폴더를 이미지에 복사, `npm run build`를 통해 build폴더에 빌드한 프로젝트(static 파일)가 저장됩니다.

실제 컨테이너로 생성되는 건 다음 이미지인데요, `nginx:stable-alpine` 이미지를 베이스로 설정하고, COPY의 옵션으로 `--from=build-stage` 를 통해 아까 빌드했던 파일들을 nginx의 서비스 폴더인 `/usr/share/nginx/html`으로 복사합니다.

그 후 80포트로 익스포팅 하고 CMD를 통해 nginx를 백그라운드에서 실행하는 컨테이너를 실행하도록 하였습니다.

✨ React의 경우 npm run build를 했을 때 생성되는 폴더가 dist가 아닌 build이므로 폴더명에 주의해주시면 됩니다!

Vue 도커파일에서 #으로 주석처리한 부분은 nginx 설정에 사용되는 부분입니다. 뒤에서 nginx 설정할 때 설명하겠습니다.

프로젝트의 도커 파일 설정은 이제 완료되었습니다! 다음은 젠킨스에서 이 도커파일을 이용해서 이미지를 생성하도록 해보겠습니다.

🍀 ****젠킨스에서 DockerFile 이용 도커 이미지 생성****

![Untitled](%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5%208517c03771dc466cbe472774aea3bc4b/Untitled%2039.png)

젠킨스 프로젝트 페이지에서, 구성 버튼을 클릭합니다.

![Untitled](%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5%208517c03771dc466cbe472774aea3bc4b/Untitled%2040.png)

그럼 아까 프로젝트 생성할 때의 창과 비슷한 창이 나타납니다. Build 탭으로 이동하고, 아까 프로젝트 생성할 때 pwd로 적어두었던 명령어를 다음 명령어로 바꾸어줍니다.

💣 **캡쳐와 코드의 폴더 위치가 다른 이유는 위 캡쳐는 제가 참고한 사이트이고 아래 코드는 제 실제 코드 기준이기 때문입니다. 폴더 위치, 이름은 사용하시는 분의 상황에 맞게 변경하시면 되겠습니다.**

```jsx
docker image prune -a --force
mkdir -p /var/jenkins_home/images_tar
cd /var/jenkins_home/workspace/deploytest/testproject_vue/
docker build -t vue .
docker save vue > /var/jenkins_home/images_tar/vue.tar

cd /var/jenkins_home/workspace/deploytest/testproject/
docker build -t springboot .
docker save springboot > /var/jenkins_home/images_tar/springboot.tar

ls /var/jenkins_home/images_tar
```

위 명령어에 대한 개별 설명

- docker image prune -a --force : 사용하지 않는 이미지 삭제
- mkdir -p /var/jenkins_home/images_tar : 도커 이미지 압축파일을 저장할 폴더 생성
- cd /var/jenkins_home/workspace/deploytest/testproject_vue : 해당 경로로 이동(vue 프로젝트 폴더)
- docker build -t vue . : 도커 이미지 빌드(Vue 프로젝트)
- docker save vue > /var/jenkins_home/images_tar/vue.tar : 도커 이미지를 vue.tar로 압축하여 위에서 생성한 폴더에 저장
- cd /var/jenkins_home/workspace/deploytest/testproject/ : 해당 경로로 이동(springboot 프로젝트 폴더)
- docker build -t springboot . : 도커 이미지 빌드(springboot 프로젝트)
- docker save springboot > /var/jenkins_home/images_tar/springboot.tar : 도커 이미지를 springboot.tar로 압축하여 위에서 생성한 폴더에 저장
- ls /var/jenkins_home/images_tar : 해당 폴더에 있는 파일 목록 출력(잘 압축되어 저장되었는지 확인)

이후 저장 버튼을 눌러줍니다.

![Untitled](%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5%208517c03771dc466cbe472774aea3bc4b/Untitled%2041.png)

그 후 지금 빌드 버튼을 눌러 빌드해줍니다.

![Untitled](%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5%208517c03771dc466cbe472774aea3bc4b/Untitled%2042.png)

다음과 같이 나오면 빌드 성공입니다.

![Untitled](%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5%208517c03771dc466cbe472774aea3bc4b/Untitled%2043.png)

생성된 2개의 tar 파일을 확인해보겠습니다.

![Untitled](%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5%208517c03771dc466cbe472774aea3bc4b/Untitled%2044.png)

이 글 초반부의 젠킨스 컨테이너 생성할 때의 `docker-compose.yml` 파일이 기억 나시나요? 그 때 공유 폴더로 aws의 `/jenkins`와 `/var/jenkins_home`를 연결했었습니다.

젠킨스 컨테이너 안의 `/var/jenkins_home/images_tar` 폴더 안에 2개의 tar 파일이 생성되어있고, 폴더를 공유하는 EC2의 `/jenkins/images_tar`에도 똑같이 2개의 tar 파일이 생성되어 있는 것을 확인할 수 있습니다.

😆 여기까지 완료했으면 젠킨스에서 도커 이미지를 빌드하여 tar 압축파일로 생성하는 부분까지 완성되었습니다!

### 1.2.5 ****젠킨스에서 SSH 명령어 전송을 통해 빌드한 도커 이미지를 베이스로 컨테이너 생성(기본 배포 완료)****

🍀 ****젠킨스 SSH 연결 설정 (Publish over SSH)****

젠킨스에서 AWS으로 SSH 명령어를 전송하려면 AWS 인증 키(EC2 생성할 때 사용한 pem 파일)를 등록해주어야 합니다.

![Untitled](%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5%208517c03771dc466cbe472774aea3bc4b/Untitled%2045.png)

젠킨스 홈페이지에서 `Jenkins 관리`를 클릭하고, 이어서 `시스템 설정`을 클릭합니다.

![Untitled](%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5%208517c03771dc466cbe472774aea3bc4b/Untitled%2046.png)

시스템 설정 칸에서 스크롤을 아래로 쭉 내리면 `Public over SSH` 항목이 있습니다. 

여기서 `SSH Servers` 추가 버튼을 눌러줍니다.

![Untitled](%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5%208517c03771dc466cbe472774aea3bc4b/Untitled%2047.png)

- Name : 그냥 이름
- Hostname : EC2 IP
- Username : EC2 접속 계정 이름

위 내용을 작성하고 고급 버튼을 클릭해줍니다.

![Untitled](%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5%208517c03771dc466cbe472774aea3bc4b/Untitled%2048.png)

다른 건 건드리지 않고, `Use password authentication, or use different key` 체크박스를 체크해줍니다.

그러면 아래에 사진 처럼 Form이 생성됩니다. 다른 값은 입력하지 않고 Key에만 값을 입력하겠습니다.

![Untitled](%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5%208517c03771dc466cbe472774aea3bc4b/Untitled%2049.png)

내가 EC2에서 생성했던 키 페어 pem 파일(싸피에서 받았을 경우 싸피에서 받은 pem 파일)을 VSCode로 오픈해주겠습니다.

![Untitled](%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5%208517c03771dc466cbe472774aea3bc4b/Untitled%2050.png)

Pem 파일은 다음과 같은 구성으로 되어있습니다. 이 텍스트 내용을 전체 복사해줍니다.

💣 **Begin RSA PRIVATE KEY, END RSA PRIVATE KEY 까지 모두 복사합니다.**

![Untitled](%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5%208517c03771dc466cbe472774aea3bc4b/Untitled%2051.png)

복사한 내용을 Key 칸에 붙여넣기 해줍니다.

![Untitled](%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5%208517c03771dc466cbe472774aea3bc4b/Untitled%2052.png)

이후 `Test Configuration` 버튼을 눌렀을 때 Success가 나오면 성공입니다. 

하지만 여기서는 오류가 나는 모습입니다.

💣 테스트가 성공하셨다면 하위 SSH 연결 오류 해결 방법은 skip 하셔도 됩니다.

✨ 이 오류에 대해 구글링을 조금 해본 결과, ubuntu 버전이 18.xx 버전보다 높은 경우에 pem 키로 인증이 실패하는 경우가 있다는 것을 알게 되었습니다. 이 경우에는 Pem 키로 인증하는 것이 아닌, ubuntu 계정의 비밀번호를 설정하여 연결하는 방법을 사용하면 해결됩니다.

🍀 ****SSH 연결 오류 해결 방법****

가장 먼저, root 계정 비밀번호를 설정해줍니다. 명령어는 `sudo passwd`입니다. 

비밀번호는 공격이 어렵게 복잡하게 설정하는 것이 좋습니다.

![Untitled](%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5%208517c03771dc466cbe472774aea3bc4b/Untitled%2053.png)

비밀번호를 설정했으면 `su`  명령어를 통해 root 계정으로 접속합니다. 

이후, `passwd ubuntu` 명령어를 이용해 ubuntu 계정의 패스워드를 설정해줍니다. 

이 역시 복잡한 패스워드가 좋습니다.(잘못하면 해킹당함)

![Untitled](%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5%208517c03771dc466cbe472774aea3bc4b/Untitled%2054.png)

패스워드 설정이 완료되었습니다. 하지만, EC2에는 기본적으로 id,pw을 이용한 로그인이 차단되어있습니다. 이제 이를 해제해보겠습니다.

계속해서 root 계정으로 접속된 상태에서 `vim /etc/ssh/sshd_config` 명령어를 통해 `sshd_config` 파일을 열어줍니다.

![Untitled](%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5%208517c03771dc466cbe472774aea3bc4b/Untitled%2055.png)

그러면, 위 사진과 같이 vim 편집기가 열립니다. 이 때, 키보드를 이용하여 아래로 조금씩 내리면서 밑줄 친 부분을 찾습니다. `PasswordAuthentication`을 no에서 yes으로 바꾸고, `esc :wq` 를 통해서 저장해줍니다.

마지막으로 `service sshd reload` 명령어를 통해 sshd를 재시작해줍니다.

이제 다시 젠킨스로 돌아옵니다.

![Untitled](%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5%208517c03771dc466cbe472774aea3bc4b/Untitled%2056.png)

기존에 있던 `pem key` 데이터는 지워버립니다. 

그리고, `Passphrase/Password` 칸에 아까 설정했던 ubuntu 계정의 패스워드를 입력해줍니다.

![Untitled](%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5%208517c03771dc466cbe472774aea3bc4b/Untitled%2057.png)

다시 `Test Configuration`버튼을 눌러보겠습니다. 

이제는 Success가 뜨는 것을 확인할 수 있습니다.

SSH 연결이 완료되었습니다. 저장 버튼을 눌러 저장해주겠습니다.

🍀 ****젠킨스 빌드 후 조치로 SSH 명령어 전송(EC2에 도커 컨테이너 생성)****

![Untitled](%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5%208517c03771dc466cbe472774aea3bc4b/Untitled%2058.png)

젠킨스 프로젝트 페이지에서, 다시 구성 버튼을 클릭합니다.

![Untitled](%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5%208517c03771dc466cbe472774aea3bc4b/Untitled%2059.png)

빌드 후 조치 탭에서, 빌드 후 조치 추가를 클릭, `Send build artifacts over SSH`를 선택합니다.

![Untitled](%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5%208517c03771dc466cbe472774aea3bc4b/Untitled%2060.png)

`Source files`는 컨테이너에서 aws로 파일을 전송하는 부분인데, 

의미가 없는데도 필수 입력 사항이기 때문에 적당히 아무거나 적어줍니다. 

중요한 부분은 `Exec command`부분에 아래 명령어를 복사 붙여넣기 해줍니다.

```jsx
sudo docker load < /jenkins/images_tar/vue.tar
sudo docker load < /jenkins/images_tar/springboot.tar

if (sudo docker ps | grep "vue"); then sudo docker stop vue; fi
if (sudo docker ps | grep "springboot"); then sudo docker stop springboot; fi

sudo docker run -it -d --rm -p 80:80 -p 443:443 --name vue vue
echo "Run testproject_vue"
sudo docker run -it -d --rm -p 8080:8080  --name springboot springboot
echo "Run testproject"
```

명령어 간단 설명 (springboot와 중복되는 명령어는 한 개만 설명)

- sudo docker load < /jenkins/images_tar/vue.tar : vue.tar을 압축 해제하여 docker 이미지로 등록
- if (sudo docker ps | grep "vue”); then sudo docker stop vue; fi : vue 컨테이너가 만약 동작중이면 stop 시키기
- sudo docker run -it -d --rm -p 80:80 -p 443:443 --name vue vue : 컨테이너 생성하기 80, 443 포트로 연결, 컨테이너 이름은 vue로

이후 저장 버튼을 눌러줍니다.

![Untitled](%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5%208517c03771dc466cbe472774aea3bc4b/Untitled%2061.png)

이제 지금 빌드 버튼을 눌러 빌드해주면.

![Untitled](%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5%208517c03771dc466cbe472774aea3bc4b/Untitled%2062.png)

콘솔에서 결과를 확인할 수 있고.

서버의 80포트(HTTP)에는 Vue를

💣 **하위 캡쳐는 참고 사이트의 캡쳐를 그대로 가져와 vue 가 아닌 react 입니다.**

![Untitled](%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5%208517c03771dc466cbe472774aea3bc4b/Untitled%2063.png)

8080포트에는 SpringBoot를 서비스하게 됩니다.

💣 **하위 캡쳐는 참고 사이트의 캡쳐를 그대로 가져와 SpringBoot 가 아닌 Django 입니다.**

💣 **DB와 연결 시키신 후 Postman으로 api요청을 보내셔서 8080포트에 SpringBoot가 제대로 연결됐는지 체크해보시길 권장합니다.**

![Untitled](%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5%208517c03771dc466cbe472774aea3bc4b/Untitled%2064.png)

8080포트에는 SpringBoot를 서비스하게 됩니다.

😆 여기까지 도커 젠킨스를 이용한 CICD 자동배포가 완료되었습니다!

1. Gitlab Push Event가 일어나면
2. Jenkins에서 WebHook을 통해 자동으로 빌드를 실행
3. Jenkins에서 각각의 Vue(Nginx), SpringBoot 프로젝트 내부의 DockerFile를 이용하여 Dockerimage 생성(tar 압축파일)
4. Jenkins에서 SSH 연결을 통해 AWS에 DockerContainer 생성
5. 외부에서 접속 : 도커 컨테이너에 올라간 Nginx에서 Vue와 SpringBoot를 각각 '/', '/api'로 구분지어 연결

처음 설명했던 작동방식 1~5중에서 4번까지 완료되었습니다. 다음은 정말 마지막 설정인 Nginx Proxy 설정입니다.

## 1.3 ****Nginx를 통해 Vue와 SpringBoot 경로 설정****

이 작업을 굳이 해야할까? 싶은 사람들도 있을 거라고 생각합니다. nginx 설정을 하지 않아도 서버는 잘 서비스 되고 있기 때문이죠.

하지만 이 과정을 해놓지 않으면 Https 설정을 할 때 높은 확률로 번거로운 작업이 추가로 생길 것이고, 만약 프론트는 Https에 성공했는데 백엔드가 Https 적용에 실패한다면 Https -> http의 크로스 도메인 오류 때문에 백엔드 API를 불러올 수 없는 치명적인 오류도 생기게 됩니다.

따라서 하나의 도메인, 한 개의 Port에서 두 서비스를 구분 짓는 부분이 필요하다고 생각합니다.

마지막 Nginx 설정 부분입니다. 이 과정은, 기존 뷰와 포트가 분리되어 8080 포트를 이용해야 접속 가능한 백엔드 서비스를 80 포트를 통해 접속할 수 있도록 변경시켜주는 작업입니다.

🍀 ****nginx.conf 파일 생성****

EC2 Ubuntu 콘솔에서 `cd /jenkins/workspace/deploytest/testproject_vue` 명령으로 디렉토리를 이동합니다. 이후 `sudo mkdir deploy_conf` 명령어로 디렉토리를 생성하고 `cd deploy_conf`를 이용해 이동해줍니다. 그 후 `sudo vim nginx.conf` 명령어로 `nginx.conf` 파일을 생성하고 편집기로 이동합니다.

nginx.conf 파일

```jsx
upstream backend{
	ip_hash;
	server 172.31.62.140:8080;
}

server {
    listen       80;
    listen  [::]:80;
    server_name  localhost;

    #access_log  /var/log/nginx/host.access.log  main;

    location / {
        root   /usr/share/nginx/html;
        index  index.html index.htm;
    }

	location /api/ {
        proxy_pass http://backend/;
        proxy_redirect     off;
        proxy_set_header   Host $host;
        proxy_set_header   X-Real-IP $remote_addr;
        proxy_set_header   X-Forwarded-For $proxy_add_x_forwarded_for;
    }

    #error_page  404              /404.html;

    # redirect server error pages to the static page /50x.html
    #
    error_page   500 502 503 504  /50x.html;
    location = /50x.html {
        root   /usr/share/nginx/html;
    }

    # proxy the PHP scripts to Apache listening on 127.0.0.1:80
    #
    #location ~ \.php$ {
    #    proxy_pass   http://127.0.0.1;
    #}

    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000
    #
    #location ~ \.php$ {
    #    root           html;
    #    fastcgi_pass   127.0.0.1:9000;
    #    fastcgi_index  index.php;
    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;
    #    include        fastcgi_params;
    #}

    # deny access to .htaccess files, if Apache's document root
    # concurs with nginx's one
    #
    #location ~ /\.ht {
    #    deny  all;
    #}
}
```

✨ 위에서부터 3번째 줄, 172.31.62.140 ip 주소는 EC2 인스턴스의 Private ip 주소입니다.

파일에는 다음 내용을 복사 붙여넣기 해줍니다.

nginx 설정 파일에 대해 간략하게 설명하면,

upstream 을 통해서 backend를 로컬 ip:8080 주소와 연결시키고,

해당 주소를 location /api 에 연결시켰습니다.

기존 뷰 프로젝트는 location / 에 연결됩니다.

결과적으로 공인ip주소/api로 요청을 하면 Nginx에서 스프링부트서버로 연결을 시켜주게됩니다.

nginx와 스프링부트 서버 사이의 통신은 로컬에서 이루어지기 때문에 공인 IP를 등록할 필요가 없습니다.

따라서 가장 처음에에 EC2에 접근 허용했던 8080포트를 막아버리면, 외부에서 스프링부트 서버로는 직접 접속을 못하게 되고, nginx(80포트)를 통해서만 접속할 수 있게됩니다.

`nginx.conf` 파일 작성을 마쳤다면 `esc, :wq` 를 통해 파일을 저장해줍니다.

🍀 도커파일 수정( 프론트 도커 파일)

```jsx
FROM node:16.15.0 as build-stage
WORKDIR /var/jenkins_home/workspace/deploytest/testproject_vue
COPY package*.json ./
RUN npm install
COPY . .
RUN npm run build
FROM nginx:stable-alpine as production-stage

COPY --from=build-stage /var/jenkins_home/workspace/deploytest/testproject_vue/build /usr/share/nginx/html
COPY --from=build-stage /var/jenkins_home/workspace/deploytest/testproject_vue/deploy_conf/nginx.conf /etc/nginx/conf.d/default.conf
EXPOSE 80
CMD ["nginx", "-g","daemon off;"]
```

앞서 DockerFile 만들 때, #으로 주석처리 했던 부분을 해제해줍니다. 이 부분은 방금 생성한 nginx 설정 파일을 nginx 이미지로 옮기는 명령어였습니다.

🍀 ****최종 빌드 테스트****

도커파일이 수정사항을 반영시키려면, gitlab에 Push 해주어야합니다! 최종적으로 모든 기능이 잘 작동하는지 테스트 할 수 있는 기회가 되겠네요.

![Untitled](%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5%208517c03771dc466cbe472774aea3bc4b/Untitled%2065.png)

수정사항을 `master Branch`에 `Push`합니다.

![Untitled](%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5%208517c03771dc466cbe472774aea3bc4b/Untitled%2066.png)

`jenkins`에서 `push trigger`를 받아 `build`를 수행합니다.

![Untitled](%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5%208517c03771dc466cbe472774aea3bc4b/Untitled%2067.png)

빌드가 완료된 후, `http://공인ip/` 로 접속하면 Vue가

💣 **캡쳐가 다른 이유는 제가 참고한 사이트에서 이미지를 그대로 가져온 것이라 그렇습니다.**
💣  **사용하시는 분의 프론트 화면이 나오면 성공입니다.**

![Untitled](%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5%208517c03771dc466cbe472774aea3bc4b/Untitled%2068.png)

ㅂ`http://공인ip/api` 로 접속하면 SpringBoot가 실행되는 걸 확인할 수 있습니다.

![Untitled](%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5%208517c03771dc466cbe472774aea3bc4b/Untitled%2069.png)

EC2 인바운드규칙에서 8080포트 접속을 차단했습니다. `http://공인ip:8080`
 더이상 8080포트로는 접속이 되지 않네요.

## 1.5 SSL 설정

**참고사이트**

[SSL설정](https://sinawi.tistory.com/410?category=879243)

3개월 인증서를 만들어 주는 확장 프로그램 certbot을 이용해 진행합니다.

SSL 인증서 발급 방법에는 3~4가지가 있습니다.

1. standalone
    
    ***사이트 작동을 멈추고 이 사이트의 네크워킹을 이용해 사이트 유효성을 확인해 Let’s Encrypt SSL 인증서를 발급하는 방식***
    
    ***. 80포트로 가상 staandalone 웹서버를 띄워 인증서를 발급***
    
    ***. 이 방식은 동시에 여러 도메인을 발급 받을 수 있음***
    
    ***. 그렇지만 인증서 발급 전에 Nginx를 중단하고 발급 완료 후 다시 Nginx를 시작해야 함***
    
2. webhook
    
    ***사이트 디렉토리 내에 인증서 유효성을 확인할 수 있는 파일을 업로드하여 인증서를 발급하는 방법***
    
    ***. 실제 작동하고 있는 웹서버의 특정 데렉토리의 특정 파일 쓰기 작업을 통해서 인증***
    
    ***. 이 방식의 장점은 nginx를 중단시킬 필요가 없음.***
    
    ***. 이 방법의 단점은 인증 명령에 하나의 도메인 인증서만 발급 가능***
    
3. DNS
    
    ***도메인을 쿼리해 확인되는 TXT 레코드로 사이트 유효성을 확인하는 방법***
    
    ***. 와일드 카드 방식으로 인증서를 발급 가능***
    
    ***. 이 방법은 당연하게도 서버 관리자가 도메인 DNS를 관리/수정할 수 있어야 하며***
    
    ***. 인증서 갱신 시마다 DNS에서 TXT값을 변경해야 하므로***
    
    ***외부에서 TXT 레코드를 입력할 수 있도록 DNS가 API를 제공하는 경우만 갱신 과정을 자동으로 처리*** 
    
4. 웹서버
    
    ***. Nginx나 아파치와 같은 웹서버에서 직접 SSL 인증을 실시하고 웹서버에 맞는 SSL세팅값을 부여***
    
    ***. 발급이나 갱신을 위해 웹서버를 중단시킬 필요가 없음***
    
    ***. 인증서 갱신 시 상황에 맞게 세팅을 자동으로 업데이트***
    
    ***. 사용자가 세팅을 변경할 수 있지만 자동 업데이트 시 반영되지는 않음***
    

저는 standalone 방법으로 인증서를 발급 받아 진행하였습니다.

## 1.5.1 **Certbot container 생성 및 인증서 발급**

```jsx
 cd
 sudo mkdir certbot
 cd certbot
 sudo mkdir conf www logs
 
 sudo docker pull certbot/certbot
 sudo docker run -it --rm --name certbot -p 80:80\
             -v "/home/ubuntu/certbot/conf:/etc/letsencrypt" \
             -v "/home/ubuntu/certbot/log:/var/log/letsencrypt" \
             -v "/home/ubuntu/certbot/www:/var/www/certbot" \
             certbot/certbot certonly
```

패키지 설명

cd : 기본 디렉토리(폴더) 이동

sudo mkdir certbot : 이름이 certbot 인 디렉토리(폴더) 생성

cd certbot : certbot 폴더 안으로 이동

sudo mkdir conf www logs : 이름이 conf, www, logs 인 디렉토리(폴더) 생성

sudo docker pull certbot/certbot : certbot 컨테이너를 pull 받는다.

sudo docker run -it —rm —name certbot -p 80:80 \ : 컨테이너 이름이 certbot인 컨테이너를 포트포워딩(외부 접근 포트 80: 내부 접근 포트 80)하여 실행시킨다.

-v :/home/ubuntu/certbot/conf:/etc/letsencrypt” \ : 볼륨 설정 ( 매핑 ) , 나머지는 생략

certbot/certbot certonly : certbot/certbot 이름으로 컨테이너를 만들어 실행

### SSL 인증서 발급 과정

**💣 필독!!!!!!!!!!**

**💣 인증서 발급을 일정 기간 안에 5회 이상 한다면 해당 도메인에 대한 인증서 발급이 막힙니다.**

**💣 발급이 제대로 이루어지지 않는다면 직접 찾아보시고 충분히 숙지 후 진행하시길 권장드립니다.**

**인증서 발급 과정**

- standalone, agree, no, <domain_name> 으로 작성하면 인증서가 발급된다.
- domain_name은 사용하려는 실제 도메인이어야 한다.

Saving debug log to /var/log/letsencrypt/letsencrypt.log

How would you like to authenticate with the ACME CA?

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

1: Spin up a temporary webserver (standalone)

2: Place files in webroot directory (webroot)

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Select the appropriate number [1-2] then [enter] (press 'c' to cancel): 1

Enter email address (used for urgent renewal and security notices)

(Enter 'c' to cancel): <<email>> 

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Please read the Terms of Service at

. You must

agree in order to register with the ACME server. Do you agree?

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

(Y)es/(N)o: y 

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Would you be willing, once your first certificate is successfully issued, to

share your email address with the Electronic Frontier Foundation, a founding

partner of the Let's Encrypt project and the non-profit organization that

develops Certbot? We'd like to send you email about our work encrypting the web,

EFF news, campaigns, and ways to support digital freedom.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

(Y)es/(N)o: n // 광고 수신 여부

Account registered.

Please enter the domain name(s) you would like on your certificate (comma and/or

space separated) (Enter 'c' to cancel): <<domain_name>>

Requesting a certificate for <<domain_name>>

Successfully received certificate.

Certificate is saved at: /etc/letsencrypt/live/<<domain_name>>/fullchain.pem

Key is saved at:         /etc/letsencrypt/live/<<domain_name>>/privkey.pem

This certificate expires on 2021-12-25.

These files will be updated when the certificate renews.

NEXT STEPS:

- The certificate will need to be renewed before it expires. Certbot can automatically renew the certificate in the background, but you may need to take steps to enable that functionality. See  for instructions.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

If you like Certbot, please consider supporting our work by:

* Donating to ISRG / Let's Encrypt:

* Donating to EFF:

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

### 1.5.2 **jenkins pipeline 수정**

```jsx
sudo docker load < /jenkins/images_tar/vue.tar
sudo docker load < /jenkins/images_tar/springboot.tar

if (sudo docker ps | grep "vue"); then sudo docker stop vue; fi
if (sudo docker ps | grep "springboot"); then sudo docker stop springboot; fi

sudo docker run -it -d --rm -p 80:80 -p 443:443 -v /home/ubuntu/certbot/conf:/etc/letsencrypt/ -v /home/ubuntu/certbot/www:/var/www/certbot --name vue vue
echo "Run FE"
sudo docker run -it -d --rm -p 8080:8080 --name springboot springboot
echo "Run BE"
```

인증서를 추가해야하므로 도커 컨테이너와 certbot 인증서가 있는 디렉토리를 연결한다.

(호스트와 컨테이너 볼륨을 연결한다)

### 1.5.3 **Nginx 설정(conf.d/default.conf)**

우분투 서버

```jsx
cd
cd ../..
cd jenkins/workspace/deploytest/testproject_vue/deploy_conf/
sudo vim nginx.conf
```

nginx.conf 파일

- http의 기본 포트는 `80`이다.
- https의 기본 포트는 `443`이다.
- https 설정은 80포트(http)로 들어오면 443(https)포트로 리다이렉션 시켰다.
- 그리고 리버스 프록시도 설정했다. /api로 들어오면 백엔드서버에 연결하였다.

```jsx
upstream backend{
        ip_hash;
        server 172.31.62.140:8080;
}

map $http_upgrade $connection_upgrade {
        default upgrade;
        ..      close;
}

server {
        listen 80;
        server_name <<domain_address>>;
        location / {
                return 301 https://$host$request_uri;
        }
}

server {

    listen       443 ssl;
    server_name <<domain_address>>;

    #access_log  /var/log/nginx/host.access.log  main;

    ssl_certificate /etc/letsencrypt/live/<<domain_address>>/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/<<domain_address>>/privkey.pem;
    ssl_protocols TLSv1 TLSv1.1 TLSv1.2 SSLv3;
    ssl_ciphers ALL;

    location / {
     root /usr/share/nginx/html;
     index index.html index.htm
     proxy_redirect off;
     charset utf-8;
     try_files $uri $uri/ /index.html;
		
		 proxy_http_version 1.1;
     proxy_set_header Upgrade $http_upgrade;
     proxy_set_header Connection "upgrade";
     proxy_set_header Host $host;
     proxy_set_header X-Real-IP $remote_addr;
     proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
     proxy_set_header X-Forwarded-Proto $scheme;
     proxy_set_header X-Nginx-Proxy true;
   }

   location /api/ {
     rewrite ^/api/(.*|$) /$1  break;
     proxy_pass http://backend/;
     proxy_redirect off;
     charset utf-8;

     proxy_http_version 1.1;
     proxy_set_header Upgrade $http_upgrade;
     proxy_set_header Connection $connection_upgrade;
     proxy_set_header Host $http_host;
     proxy_set_header X-Real-IP $remote_addr;
     proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
     proxy_set_header X-Forwarded-Proto $scheme;
     proxy_set_header X-Nginx-Proxy true;
   }

    #error_page  404              /404.html;
		# redirect server error pages to the static page /50x.html
    #
    error_page   500 502 503 504  /50x.html;
    location = /50x.html {
        root   /usr/share/nginx/html;
    }

    # proxy the PHP scripts to Apache listening on 127.0.0.1:80
    #
    #location ~ \.php$ {
    #    proxy_pass   http://127.0.0.1;
    #}

    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000
    #
    #location ~ \.php$ {
    #    root           html;
    #    fastcgi_pass   127.0.0.1:9000;
    #    fastcgi_index  index.php;
    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;
    #    include        fastcgi_params;
    #}

    # deny access to .htaccess files, if Apache's document root
    # concurs with nginx's one
    #
    #location ~ /\.ht {
    #    deny  all;
    #}
}
```

✨ upstream은 [proxy_pass](https://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_pass) , [fastcgi_pass](https://nginx.org/en/docs/http/ngx_http_fastcgi_module.html#fastcgi_pass) , [uwsgi_pass](https://nginx.org/en/docs/http/ngx_http_uwsgi_module.html#uwsgi_pass) , [scgi_pass](https://nginx.org/en/docs/http/ngx_http_scgi_module.html#scgi_pass) , [memcached_pass](https://nginx.org/en/docs/http/ngx_http_memcached_module.html#memcached_pass) 및 [grpc_pass](https://nginx.org/en/docs/http/ngx_http_grpc_module.html#grpc_pass)
의 지시자에 대해서 참조할 수 있는 서버 그룹을 정의 하는데 사용합니다. 

upstream 을 통해서 backend를 로컬 ip:8080 주소와 연결시킵니다.

(그리고 nginx가 받았던 리퀘스트를 해당 서버에 넘김)

위에서부터 3번째 줄, 172.31.62.140 ip 주소는 EC2 인스턴스의 Private ip 주소입니다.

11~17번째 줄 : 

이는 reverse proxy 서버는 80번 포트를 listen하고 server_name은 domain_address 로 지정했다.

(**도메인으로 지정할 경우 포트는 같지만 도메인기준으로 proxy_pass도 가능해진다)**

proxy_pass설정을 보면 `/`로 들어올경우 

위에서 정의한 upstream docker-nginx(172.31.62.140 container의 8080포트)로 proxy한다.

https 경로로 접근한다면 https 기본 포트인 443으로 연결됩니다.

프론트는 / 경로로, 백은 /api 로 요청하기로 약속돼있다는 전제로 

/ 로 경로가 들어오면 프론트 창으로 연결되고, /api 경로로 들어오면 upstream 경로로 연결됩니다.

`nginx.conf` 파일 작성을 마쳤다면 `esc, :wq` 를 통해 파일을 저장해줍니다.